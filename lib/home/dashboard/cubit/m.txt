import 'dart:async';

import 'package:bloc/bloc.dart';
import 'package:hourtag/home/dashboard/model/company_profile/company_profile_model.dart';
import 'package:hourtag/home/dashboard/model/ongoing_shifts/ongoing_shift_model.dart';
import 'package:hourtag/home/dashboard/model/start_shift/start_shift_model.dart';
import 'package:hourtag/home/dashboard/model/team_activity/team_activity_model.dart';
import 'package:hourtag/home/dashboard/model/user_profile/user_profile_model.dart';
import 'package:hourtag/home/dashboard/repo/dashboard_repo.dart';

part 'dashboard_state.dart';

class DashboardCubit extends Cubit<DashboardState> {
  DashboardCubit(this.authToken) : super(DashboardState.initial());
  DashboardRepo repo = DashboardRepo();
  final String authToken;
  void changeSelectedIndex(int index) {
    emit(state.copyWith(selectedIndex: index));
  }

  void toogleStart(bool val) {
    emit(state.copyWith(started: val));
  }

  Timer? _timer;
  void startTimer({bool? onlyCheck}) async {
    try {
      _timer?.cancel();
      StartShiftModel? data;
      if (state.ongoingShiftModel.ongoingShift == null && onlyCheck != true) {
        data = await repo.startShift(
            state.userProfileModel.selectedCompany?.companyId ?? 0,
            state.companyProfileModel.projects?[state.selectedIndex].id ?? 0,
            authToken);
        emit(state.copyWith(startShiftModel: data));
      }
      int second = state.ongoingShiftModel.ongoingShift == null
          ? findTimeForStarted(startedTime: data?.start_time?.toString() ?? "")
          : findTimeForStarted(
              startedTime: state.ongoingShiftModel.ongoingShift?.start_time
                      ?.toString() ??
                  "");
      if (onlyCheck == true && state.ongoingShiftModel.ongoingShift != null) {
        _timer =
            Timer.periodic(const Duration(seconds: 1), (Timer timer) async {
          second++;
          emit(state.copyWith(durationInSeconds: second));
        });

        toogleStart(true);
      } else {
        _timer =
            Timer.periodic(const Duration(seconds: 1), (Timer timer) async {
          second++;
          emit(state.copyWith(durationInSeconds: second));
        });

        toogleStart(true);
      }
    } catch (e) {
      print("mero muji: ${e.toString()}");
    }
  }

  int findTimeForStarted({required String startedTime}) {
    DateTime startTime = DateTime.parse(startedTime);
    DateTime currentTime = DateTime.now();
    Duration difference = currentTime.difference(startTime);
    int seconds = difference.inSeconds;
    return seconds;
  }

  void stopTimer() {
    _timer?.cancel();
    toogleStart(false);
  }

  Future<void> resetTimer() async {
    emit(state.copyWith(durationInSeconds: 0));
  }

  Future<void> getUserProfile() async {
    UserProfileModel data = await repo.getDashboardData(authToken);
    List<TeamActivityModel> teamdata = await repo.getTeamActivity(
        authToken, data.selectedCompany?.companyId ?? 0);
    OngoingShiftModel ongoingShiftData = await repo.getOngoingShift(
        authToken, data.selectedCompany?.companyId ?? 0);
    CompanyProfileModel companyData = await repo.getCompanyProfile(
        authToken, data.selectedCompany?.companyId ?? 0);
    emit(state.copyWith(
        userProfileModel: data,
        status: Status.loaded,
        teamActivityModel: teamdata,
        companyProfileModel: companyData,
        ongoingShiftModel: ongoingShiftData));
    startTimer(onlyCheck: true);
  }
}
